<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ToThePoint</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6; /* Light Mode Background */
            transition: background-color 0.3s;
        }
        .dark body {
            background-color: #1f2937; /* Dark Mode Background */
        }
        #map {
            height: 400px;
            width: 100%;
            border-radius: 1rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            margin-bottom: 1.5rem;
        }
        /* Corrigido: Aplicando preto absoluto ao título no modo claro */
        h1.text-black {
            color: #000000;
        }
        /* NOVO: Força o título a ser branco no modo escuro */
        .dark h1.text-black {
            color: #FFFFFF !important; 
        }

        /* Base styles for dark mode elements */
        .dark .bg-white { background-color: #374151; }
        .dark .text-gray-800 { color: #f3f4f6; }
        .dark .text-gray-600 { color: #d1d5db; }
        .dark .text-gray-500 { color: #9ca3af; }
        .dark .bg-gray-100 { background-color: #4b5563; }
        .dark .text-gray-700 { color: #f3f4f6; }
        .dark input, .dark textarea { background-color: #4b5563; border-color: #6b7280; color: #f3f4f6; }
        .dark .bg-gray-200 { background-color: #4b5563; }
        .dark .divide-gray-200 > * { border-color: #6b7280; }
        .dark .hover\:bg-gray-50:hover { background-color: #4b5563; }

        /* Modal styling */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.4);
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
        }
        .modal-content {
            background-color: #fefefe;
            margin: 15% auto;
            padding: 20px;
            border-radius: 1rem;
            box-shadow: 0 8px 16px rgba(0,0,0,0.2);
            width: 80%;
            max-width: 400px;
            text-align: center;
        }
        .dark .modal-content {
            background-color: #374151;
            color: #f3f4f6;
        }
        .modal-buttons {
            display: flex;
            justify-content: center;
            gap: 1rem;
            margin-top: 1rem;
        }
        /* Confirmação visual de edição (pisca verde) */
        .edited-flash {
            background-color: #d1fae5 !important; /* Tailwind green-100 */
            transition: background-color 0.5s ease-out;
        }
        .dark .edited-flash {
            background-color: #10b981 !important; /* Tailwind emerald-500 dark mode flash */
        }
        /* Destaque visual para linhas corrigidas (fundo azul) */
        .corrected-row {
            background-color: #eff6ff; /* blue-50 */
        }
        .dark .corrected-row {
            background-color: #1e3a8a; /* dark blue-900 */
        }
        .corrected-row:hover {
            background-color: #dbeafe !important; /* blue-100 */
        }
        .dark .corrected-row:hover {
            background-color: #1e40af !important; /* dark blue-800 */
        }
    </style>
</head>
<body class="flex items-center justify-center min-h-screen p-4 transition-colors duration-300">

    <div id="main-container" class="bg-white p-8 rounded-2xl shadow-xl w-full max-w-2xl text-center relative transition-colors duration-300">
        <!-- Botões de Ação no Topo -->
        <div class="absolute top-4 right-4 flex gap-2">
            <!-- Botão de Configurações (NOVO) -->
            <button id="settings-button" class="p-2 rounded-full bg-gray-100 hover:bg-gray-200 dark:bg-gray-700 dark:hover:bg-gray-600 transition-colors duration-300 focus:outline-none">
                <svg class="h-6 w-6 text-gray-600 dark:text-gray-300" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z"></path><path stroke-linecap="round" stroke-linejoin="round" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path></svg>
            </button>
            <!-- Botão de Toggle Dark Mode -->
            <button id="theme-toggle" class="p-2 rounded-full bg-gray-100 hover:bg-gray-200 dark:bg-gray-700 dark:hover:bg-gray-600 transition-colors duration-300 focus:outline-none">
                <svg id="sun-icon" class="h-6 w-6 text-orange-400" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><circle cx="12" cy="12" r="5" fill="currentColor" stroke="none"/><path stroke-linecap="round" stroke-linejoin="round" d="M12 2v2M12 20v2M4.22 4.22l1.42 1.42M18.36 18.36l1.42 1.42M4.22 18.36l1.42-1.42M18.36 4.22l1.42-1.42M2 12h2M20 12h2"/></svg>
                <svg id="moon-icon" class="h-6 w-6 text-indigo-200" fill="currentColor" viewBox="0 0 24 24" style="display: none;"><path d="M21 12.79a9 9 0 1 1-9.92-9.92 7 7 0 0 0 9.92 9.92z"/></svg>
            </button>
        </div>
        
        <!-- Logo -->
        <h1 class="text-4xl font-bold mb-4 text-black dark:text-white flex items-center justify-center">
            <span>ToTheP</span>
            <svg class="h-10 w-10 text-blue-600 mx-[-6px]" fill="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5a2.5 2.5 0 110-5 2.5 2.5 0 010 5z"/></svg>
            <span>int</span>
        </h1>
        <p class="text-gray-700 dark:text-gray-400 text-sm mb-4">Aplicação desenvolvida por Ailthon Cavagnari sob orientação do Professor Rafael Kalinoski no âmbito da disciplina de Planejamento Urbano do curso de Arquitetura e Urbanismo do Centro Universitário de Tecnologia de Curitiba (UNIFATEC).</p>
        <p class="text-gray-800 dark:text-gray-300 mb-6">Capture coordenadas, adicione um nome e visualize os pontos em tempo real.</p>
        
        <div id="map"></div>

        <!-- Barra de pesquisa -->
        <div class="mb-4 flex gap-2">
            <input type="text" id="search-input" placeholder="Pesquisar endereço ou coordenadas..." class="flex-1 p-3 rounded-xl border border-gray-300 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent">
            <button id="search-button" class="bg-blue-600 text-white font-bold py-3 px-6 rounded-xl shadow-lg hover:bg-blue-700 transition-colors duration-200 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50">
                Pesquisar
            </button>
        </div>

        <div id="status-message" class="p-3 rounded-xl mb-4 text-sm font-medium hidden"></div>

        <div id="coordinates-display" class="bg-gray-100 p-4 rounded-xl mb-6 hidden">
            <p class="text-gray-500 text-sm">Coordenadas Atuais:</p>
            <p id="latitude-text" class="text-xl font-bold text-gray-700">Latitude: --</p>
            <p id="longitude-text" class="text-xl font-bold text-gray-700">Longitude: --</p>
            <p id="accuracy-text" class="text-sm font-medium text-gray-700">Precisão: --</p>
        </div>

        <div class="mb-4 hidden" id="point-name-container">
            <input type="text" id="point-name-input" placeholder="Digite o nome da sua marcação aqui" class="w-full p-3 rounded-xl border border-gray-300 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent">
        </div>

        <div class="flex flex-col gap-4">
            <button id="start-button" class="w-full bg-blue-600 text-white font-bold py-3 px-6 rounded-xl shadow-lg hover:bg-blue-700 transition-colors duration-200 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50">Iniciar GPS</button>
            <button id="manual-capture-button" class="w-full bg-blue-400 text-white font-bold py-3 px-6 rounded-xl shadow-lg hover:bg-blue-500 transition-colors duration-200 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50">Marcar Manualmente</button>
            <button id="capture-button" class="w-full bg-green-500 text-white font-bold py-3 px-6 rounded-xl shadow-lg hover:bg-green-600 transition-colors duration-200 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-opacity-50" disabled>Registrar Ponto</button>
            <button id="stop-button" class="w-full bg-gray-500 text-white font-bold py-3 px-6 rounded-xl shadow-lg hover:bg-gray-600 transition-colors duration-200 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-opacity-50 hidden">Parar/Resetar</button>
            <button id="download-button" class="w-full bg-red-500 text-white font-bold py-3 px-6 rounded-xl shadow-lg hover:bg-red-600 transition-colors duration-200 focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-opacity-50" disabled>Exportar CSV</button>
            <button id="clear-local-data-button" class="w-full bg-yellow-500 text-white font-bold py-3 px-6 rounded-xl shadow-lg hover:bg-yellow-600 transition-colors duration-200 focus:outline-none focus:ring-2 focus:ring-yellow-500 focus:ring-opacity-50" disabled>Limpar Todos os Dados Locais</button>
        </div>
        
        <div id="points-preview" class="mt-8 hidden">
            <h3 class="text-xl font-bold mb-4 text-gray-800">Pontos Capturados: (<span id="points-count">0</span>)</h3>
            <div class="overflow-x-auto">
                <table class="min-w-full bg-white rounded-xl shadow-lg">
                    <thead class="bg-gray-200">
                        <tr>
                            <th class="py-2 px-4 text-left text-xs font-semibold text-gray-600 uppercase tracking-wider">#</th>
                            <th class="py-2 px-4 text-left text-xs font-semibold text-gray-600 uppercase tracking-wider">Nome do Ponto</th>
                            <th class="py-2 px-4 text-left text-xs font-semibold text-gray-600 uppercase tracking-wider">Latitude (Final)</th>
                            <th class="py-2 px-4 text-left text-xs font-semibold text-gray-600 uppercase tracking-wider">Longitude (Final)</th>
                            <th class="py-2 px-4 text-left text-xs font-semibold text-gray-600 uppercase tracking-wider">Status</th>
                            <th class="py-2 px-4 text-left text-xs font-semibold text-gray-600 uppercase tracking-wider">Precisão Orig.</th>
                            <th class="py-2 px-4 text-center text-xs font-semibold text-gray-600 uppercase tracking-wider">Ação</th>
                        </tr>
                    </thead>
                    <tbody id="points-table-body" class="divide-y divide-gray-200 text-gray-800">
                    </tbody>
                </table>
            </div>
        </div>
    </div>

    <!-- Modais -->
    <div id="confirmation-modal" class="modal">
        <div class="modal-content">
            <p>Gostaria de incluir a localização aproximada desse ponto?</p>
            <div class="modal-buttons">
                <button id="confirm-yes" class="bg-green-500 text-white font-bold py-2 px-4 rounded-xl shadow-lg hover:bg-green-600">Sim</button>
                <button id="confirm-no" class="bg-red-500 text-white font-bold py-2 px-4 rounded-xl shadow-lg hover:bg-red-600">Não</button>
            </div>
        </div>
    </div>
    <div id="clear-data-modal" class="modal">
        <div class="modal-content">
            <p class="font-bold text-lg mb-2">Atenção!</p>
            <p>Tem certeza que deseja apagar TODOS os pontos salvos localmente? Esta ação é irreversível.</p>
            <div class="modal-buttons">
                <button id="clear-data-confirm" class="bg-red-600 text-white font-bold py-2 px-4 rounded-xl shadow-lg hover:bg-red-700">Sim, apagar tudo</button>
                <button id="clear-data-cancel" class="bg-gray-500 text-white font-bold py-2 px-4 rounded-xl shadow-lg hover:bg-gray-600">Cancelar</button>
            </div>
        </div>
    </div>
     <!-- Modal de Configurações (NOVO) -->
    <div id="settings-modal" class="modal">
        <div class="modal-content text-left">
            <h3 class="text-xl font-bold mb-4 text-center">Configurações</h3>
            <div class="mb-4">
                <label for="api-key-input" class="block text-sm font-medium text-gray-700 mb-1">Chave de API do Google Maps</label>
                <input type="password" id="api-key-input" class="w-full p-2 rounded-lg border border-gray-300 focus:outline-none focus:ring-2 focus:ring-blue-500" placeholder="Cole sua chave aqui">
                <p class="text-xs text-gray-500 mt-1">Sua chave é salva apenas no seu navegador e não é compartilhada.</p>
            </div>
            <div class="modal-buttons">
                <button id="save-settings-button" class="bg-blue-600 text-white font-bold py-2 px-4 rounded-xl shadow-lg hover:bg-blue-700">Salvar</button>
                <button id="close-settings-button" class="bg-gray-500 text-white font-bold py-2 px-4 rounded-xl shadow-lg hover:bg-gray-600">Fechar</button>
            </div>
        </div>
    </div>
    
    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
    <script>
    document.addEventListener('DOMContentLoaded', () => {

        // =================================================================
        // MÓDULO 1: StateManager - Gerencia o estado da aplicação
        // =================================================================
        const StateManager = {
            localCoordinates: [],
            markers: [],
            map: null,
            watchId: null,
            lastKnownPosition: null,
            lastKnownAccuracy: null,
            lastKnownAddress: null,
            isManualCapture: false,
            manualMarker: null,
            isCollecting: false,
            currentLocationMarker: null,
            accuracyCircle: null,
        };

        // =================================================================
        // MÓDULO 2: UIManager - Gerencia todos os elementos da UI
        // =================================================================
        const UIManager = {
            // Referências aos Elementos do DOM
            elements: {
                statusMessage: document.getElementById('status-message'),
                coordinatesDisplay: document.getElementById('coordinates-display'),
                latitudeText: document.getElementById('latitude-text'),
                longitudeText: document.getElementById('longitude-text'),
                accuracyText: document.getElementById('accuracy-text'),
                startButton: document.getElementById('start-button'),
                manualCaptureButton: document.getElementById('manual-capture-button'),
                captureButton: document.getElementById('capture-button'),
                downloadButton: document.getElementById('download-button'),
                stopButton: document.getElementById('stop-button'),
                pointNameInput: document.getElementById('point-name-input'),
                pointNameContainer: document.getElementById('point-name-container'),
                searchInput: document.getElementById('search-input'),
                searchButton: document.getElementById('search-button'),
                pointsPreview: document.getElementById('points-preview'),
                pointsCount: document.getElementById('points-count'),
                pointsTableBody: document.getElementById('points-table-body'),
                themeToggle: document.getElementById('theme-toggle'),
                sunIcon: document.getElementById('sun-icon'),
                moonIcon: document.getElementById('moon-icon'),
                clearLocalDataButton: document.getElementById('clear-local-data-button'),
                
                // Modais
                confirmationModal: document.getElementById('confirmation-modal'),
                confirmYesButton: document.getElementById('confirm-yes'),
                confirmNoButton: document.getElementById('confirm-no'),
                clearDataModal: document.getElementById('clear-data-modal'),
                clearDataConfirm: document.getElementById('clear-data-confirm'),
                clearDataCancel: document.getElementById('clear-data-cancel'),
                settingsModal: document.getElementById('settings-modal'),
                settingsButton: document.getElementById('settings-button'),
                saveSettingsButton: document.getElementById('save-settings-button'),
                closeSettingsButton: document.getElementById('close-settings-button'),
                apiKeyInput: document.getElementById('api-key-input'),
            },

            init() {
                this.applyTheme(SettingsManager.getTheme());
            },

            setButtonText(id, text) {
                const button = this.elements[id];
                if (button) button.textContent = text;
            },

            setUIState(collectingStatus) {
                StateManager.isCollecting = collectingStatus;
                const isPointReady = StateManager.lastKnownPosition !== null;

                if (!StateManager.isCollecting) {
                    this.setButtonText('startButton', 'Iniciar GPS');
                    this.setButtonText('manualCaptureButton', 'Marcar Manualmente');
                    this.setButtonText('searchButton', 'Pesquisar');
                }

                this.elements.startButton.disabled = StateManager.isCollecting;
                this.elements.manualCaptureButton.disabled = StateManager.isCollecting;
                this.elements.captureButton.disabled = !isPointReady;
                this.elements.downloadButton.disabled = StateManager.localCoordinates.length === 0;
                this.elements.clearLocalDataButton.disabled = StateManager.localCoordinates.length === 0;
                this.elements.pointNameInput.disabled = !isPointReady;
                
                this.elements.pointNameContainer.classList.toggle('hidden', !isPointReady);
                this.elements.coordinatesDisplay.classList.toggle('hidden', !isPointReady);
                if (!isPointReady) this.elements.accuracyText.textContent = 'Precisão: --';
                
                this.elements.stopButton.classList.toggle('hidden', !StateManager.isCollecting && !StateManager.isManualCapture);
                this.elements.pointsPreview.classList.toggle('hidden', StateManager.localCoordinates.length === 0);
            },

            showMessage(message, type = 'info') {
                const el = this.elements.statusMessage;
                el.textContent = message;
                el.className = 'p-3 rounded-xl mb-4 text-sm font-medium'; // Reset classes
                
                switch(type) {
                    case 'error': el.classList.add('bg-red-100', 'text-red-800', 'dark:bg-red-900', 'dark:text-red-300'); break;
                    case 'success': el.classList.add('bg-green-100', 'text-green-800', 'dark:bg-green-900', 'dark:text-green-300'); break;
                    default: el.classList.add('bg-yellow-100', 'text-yellow-800', 'dark:bg-yellow-900', 'dark:text-yellow-300'); break;
                }
            },

            showModal(modalElement) {
                modalElement.style.display = 'block';
            },

            hideModal(modalElement) {
                modalElement.style.display = 'none';
            },
            
            showConfirmation(question) {
                return new Promise(resolve => {
                    const modal = this.elements.confirmationModal;
                    modal.querySelector('p').textContent = question;
                    this.showModal(modal);
                    
                    this.elements.confirmYesButton.onclick = () => { this.hideModal(modal); resolve(true); };
                    this.elements.confirmNoButton.onclick = () => { this.hideModal(modal); resolve(false); };
                });
            },

            showClearDataConfirmation() {
                 return new Promise(resolve => {
                    const modal = this.elements.clearDataModal;
                    this.showModal(modal);
                    this.elements.clearDataConfirm.onclick = () => { this.hideModal(modal); resolve(true); };
                    this.elements.clearDataCancel.onclick = () => { this.hideModal(modal); resolve(false); };
                });
            },

            updateCoordinatesDisplay(lat, lon, acc) {
                this.elements.latitudeText.textContent = `Latitude: ${lat.toFixed(6)}`;
                this.elements.longitudeText.textContent = `Longitude: ${lon.toFixed(6)}`;
                const accuracyColorClass = this.getAccuracyColor(acc);
                this.elements.accuracyText.className = `text-sm font-medium ${accuracyColorClass}`;
                this.elements.accuracyText.textContent = `Precisão: \u00B1 ${acc.toFixed(1)}m`;
            },
            
            getAccuracyColor(accuracy) {
                if (accuracy === 0) return 'text-blue-500 dark:text-blue-400';
                if (accuracy <= 5) return 'text-green-500 dark:text-green-400';
                if (accuracy <= 15) return 'text-yellow-500 dark:text-yellow-400';
                return 'text-red-500 dark:text-red-400';
            },

            updatePreviewTable() {
                this.elements.pointsTableBody.innerHTML = '';
                this.elements.pointsCount.textContent = StateManager.localCoordinates.length;
                
                StateManager.markers.forEach(marker => StateManager.map.removeLayer(marker));
                StateManager.markers = [];

                StateManager.localCoordinates.forEach((point, index) => {
                    MapManager.createPointMarker(point);
                    this.createTableRow(point, index);
                });

                if (StateManager.markers.length > 0) {
                    const group = new L.featureGroup(StateManager.markers);
                    StateManager.map.fitBounds(group.getBounds());
                }
                this.setUIState(false);
            },
            
            createTableRow(point, index) {
                const row = document.createElement('tr');
                const statusString = DataManager.getPointStatus(point);
                let rowClass = 'hover:bg-gray-50 dark:hover:bg-gray-600';
                if ((point.accuracy === 0 && point.originalAccuracy !== 0) || point.nameEdited) {
                    rowClass = 'corrected-row';
                }
                row.className = rowClass + ' transition-colors duration-150';

                row.innerHTML = `
                    <td class="py-2 px-4 whitespace-nowrap text-sm">${index + 1}</td>
                    <td class="py-2 px-4 whitespace-nowrap text-sm font-medium cursor-text" contenteditable="true" data-id="${point.id}" onblur="App.handleEditPointName(this, ${point.id})">${point.name}</td>
                    <td class="py-2 px-4 whitespace-nowrap text-sm">${point.latitude.toFixed(6).replace('.', ',')}</td>
                    <td class="py-2 px-4 whitespace-nowrap text-sm">${point.longitude.toFixed(6).replace('.', ',')}</td>
                    <td class="py-2 px-4 whitespace-nowrap text-sm text-center font-medium">${statusString}</td>
                    <td class="py-2 px-4 whitespace-nowrap text-sm text-center font-semibold">${DataManager.getOriginalAccuracyText(point)}</td>
                    <td class="py-2 px-4 whitespace-nowrap text-sm text-center">
                        <button onclick="App.handleDeletePoint(${point.id})" class="text-red-600 hover:text-red-800 transition-colors duration-150 p-1 rounded-full hover:bg-red-100 focus:outline-none focus:ring-2 focus:ring-red-500 dark:hover:bg-red-900">
                            <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 6v10h6V6H7z" clip-rule="evenodd" /></svg>
                        </button>
                    </td>`;
                this.elements.pointsTableBody.appendChild(row);
            },

            applyTheme(theme) {
                const isDark = theme === 'dark';
                document.body.classList.toggle('dark', isDark);
                this.elements.sunIcon.style.display = isDark ? 'none' : 'block';
                this.elements.moonIcon.style.display = isDark ? 'block' : 'none';
            },

            toggleDarkMode() {
                const newTheme = document.body.classList.contains('dark') ? 'light' : 'dark';
                this.applyTheme(newTheme);
                SettingsManager.saveTheme(newTheme);
            }
        };

        // =================================================================
        // MÓDULO 3: MapManager - Gerencia o mapa e a geolocalização
        // =================================================================
        const MapManager = {
            init() {
                StateManager.map = L.map('map').setView([-25.4284, -49.2733], 13);
                this.addBaseLayers();
                StateManager.map.on('click', this.onMapClick.bind(this));
            },

            addBaseLayers() {
                const baseLayers = {
                    "Híbrido": L.layerGroup([
                        L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', { attribution: 'Esri, etc.' }),
                        L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/Reference/World_Boundaries_and_Places/MapServer/tile/{z}/{y}/{x}', { pane: 'markerPane' })
                    ]).addTo(StateManager.map),
                    "Ruas": L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Street_Map/MapServer/tile/{z}/{y}/{x}', { attribution: 'Esri' }),
                    "Topográfico": L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Topo_Map/MapServer/tile/{z}/{y}/{x}', { attribution: 'Esri' }),
                };
                L.control.layers(baseLayers).addTo(StateManager.map);
            },

            async onMapClick(e) {
                this.stopCollecting();
                StateManager.isManualCapture = true;
                
                UIManager.setButtonText('manualCaptureButton', 'Buscando...');
                
                const { lat, lng } = e.latlng;
                await this.updateMapForManualPoint(lat, lng);
                UIManager.showMessage('Ponto selecionado. Clique em "Registrar Ponto" para salvar.', 'success');
            },

            async reverseGeocode(lat, lon) {
                const apiKey = SettingsManager.getApiKey();
                if (!apiKey) {
                    UIManager.showMessage('Chave de API do Google Maps não configurada. Use o ícone de engrenagem.', 'error');
                    return 'Endereço não encontrado (API Key ausente)';
                }
                try {
                    const response = await fetch(`https://maps.googleapis.com/maps/api/geocode/json?latlng=${lat},${lon}&key=${apiKey}`);
                    const data = await response.json();
                    if (data.status === 'OK' && data.results.length > 0) {
                        return data.results[0].formatted_address;
                    }
                } catch (error) {
                    console.error('Erro na geocodificação reversa:', error);
                }
                return 'Endereço não encontrado';
            },

            startCollecting() {
                this.stopCollecting();
                StateManager.isCollecting = true;
                UIManager.setButtonText('startButton', 'Localizando...');
                UIManager.showMessage('Acessando localização...', 'info');
                UIManager.elements.coordinatesDisplay.classList.remove('hidden');

                if (!navigator.geolocation) {
                    UIManager.showMessage("Seu navegador não suporta geolocalização.", 'error');
                    UIManager.setUIState(false);
                    return;
                }

                const options = { enableHighAccuracy: true, timeout: 15000, maximumAge: 0 };
                StateManager.watchId = navigator.geolocation.watchPosition(
                    position => {
                        const { latitude, longitude, accuracy } = position.coords;
                        StateManager.lastKnownPosition = { latitude, longitude };
                        StateManager.lastKnownAccuracy = accuracy;
                        
                        UIManager.updateCoordinatesDisplay(latitude, longitude, accuracy);
                        this.updateCurrentLocationMarker({ lat: latitude, lng: longitude }, accuracy);
                        StateManager.map.setView([latitude, longitude], StateManager.map.getZoom() > 16 ? StateManager.map.getZoom() : 16);
                        
                        if (StateManager.manualMarker) {
                            StateManager.map.removeLayer(StateManager.manualMarker);
                            StateManager.manualMarker = null;
                        }
                        
                        UIManager.showMessage('Localização encontrada. Pronta para capturar!', 'success');
                        UIManager.setUIState(true);
                    },
                    error => {
                        this.stopCollecting();
                        let msg = "Erro desconhecido ao obter localização.";
                        if(error.code === 1) msg = "Acesso à localização negado. Ative nas configurações.";
                        if(error.code === 2) msg = "Localização indisponível.";
                        if(error.code === 3) msg = "Tempo para obter localização esgotado.";
                        UIManager.showMessage(msg, 'error');
                    },
                    options
                );
            },

            stopCollecting() {
                if (StateManager.watchId) {
                    navigator.geolocation.clearWatch(StateManager.watchId);
                    StateManager.watchId = null;
                }
                if (StateManager.currentLocationMarker) {
                    StateManager.map.removeLayer(StateManager.currentLocationMarker);
                    StateManager.currentLocationMarker = null;
                }
                if (StateManager.accuracyCircle) {
                    StateManager.map.removeLayer(StateManager.accuracyCircle);
                    StateManager.accuracyCircle = null;
                }
                if (StateManager.manualMarker) {
                    StateManager.map.removeLayer(StateManager.manualMarker);
                    StateManager.manualMarker = null;
                }
                StateManager.lastKnownPosition = null;
                StateManager.lastKnownAccuracy = null;
                StateManager.lastKnownAddress = null;
                StateManager.isCollecting = false;
                StateManager.isManualCapture = false;
                UIManager.setUIState(false);
                UIManager.showMessage("Coleta interrompida.", "info");
            },

            updateCurrentLocationMarker(latlng, accuracy) {
                if (StateManager.currentLocationMarker) {
                    StateManager.currentLocationMarker.setLatLng(latlng);
                    StateManager.accuracyCircle.setLatLng(latlng).setRadius(accuracy);
                } else {
                    StateManager.currentLocationMarker = L.circleMarker(latlng, { radius: 8, color: '#03A9F4', fillColor: '#2196F3', fillOpacity: 0.8 }).addTo(StateManager.map).bindPopup("Sua Posição").openPopup();
                    StateManager.accuracyCircle = L.circle(latlng, { radius: accuracy, color: '#03A9F4', fillColor: '#2196F3', fillOpacity: 0.1, weight: 1 }).addTo(StateManager.map);
                }
            },
            
            createPointMarker(point) {
                const newMarker = L.marker([point.latitude, point.longitude], { draggable: true, id: point.id })
                    .addTo(StateManager.map)
                    .bindPopup(`<b>${point.name}</b><br>Status: ${DataManager.getPointStatus(point)}`)
                    .on('dragend', this.onMarkerDragEnd);
                StateManager.markers.push(newMarker);
            },
            
            onMarkerDragEnd(e) {
                const marker = e.target;
                const newLatLng = marker.getLatLng();
                const pointId = marker.options.id;
                DataManager.updatePointPosition(pointId, newLatLng.lat, newLatLng.lng);
                
                const point = StateManager.localCoordinates.find(p => p.id === pointId);
                marker.setPopupContent(`<b>${point.name}</b><br>Status: ${DataManager.getPointStatus(point)} (Corrigido)`);

                UIManager.updatePreviewTable();
                UIManager.showMessage(`Ponto '${point.name}' corrigido manualmente.`, 'info');
                
                const rowElement = UIManager.elements.pointsTableBody.querySelector(`[data-id="${pointId}"]`).closest('tr');
                if (rowElement) {
                    rowElement.classList.add('edited-flash');
                    setTimeout(() => rowElement.classList.remove('edited-flash'), 1000);
                }
            },
            
            async searchLocation(query) {
                UIManager.setButtonText('searchButton', 'Buscando...');
                const isCoordinates = /^-?\d+(\.\d+)?,\s*-?\d+(\.\d+)?$/.test(query);

                if (isCoordinates) {
                    const parts = query.split(',');
                    const lat = parseFloat(parts[0]);
                    const lon = parseFloat(parts[1]);
                    if (!isNaN(lat) && !isNaN(lon)) {
                        await this.updateMapForManualPoint(lat, lon, `Coordenadas: ${query}`);
                        UIManager.showMessage('Coordenadas localizadas no mapa.', 'success');
                    } else {
                        UIManager.showMessage('Formato de coordenadas inválido. Tente "latitude,longitude".', 'error');
                    }
                } else {
                    UIManager.showMessage('Pesquisando endereço...', 'info');
                    const apiKey = SettingsManager.getApiKey();
                    try {
                        const response = await fetch(`https://maps.googleapis.com/maps/api/geocode/json?address=${encodeURIComponent(query)}&key=${apiKey}`);
                        const data = await response.json();
                        if (data.status === 'OK' && data.results.length > 0) {
                            const location = data.results[0].geometry.location;
                            const address = data.results[0].formatted_address;
                            await this.updateMapForManualPoint(location.lat, location.lng, address);
                            UIManager.showMessage('Endereço localizado no mapa.', 'success');
                        } else {
                            UIManager.showMessage('Endereço não encontrado. Tente novamente.', 'error');
                        }
                    } catch (error) {
                        console.error("Erro na busca:", error);
                        UIManager.showMessage('Erro ao pesquisar endereço. Verifique sua conexão.', 'error');
                    }
                }
                UIManager.setButtonText('searchButton', 'Pesquisar');
                UIManager.elements.searchInput.value = '';
            },

            async updateMapForManualPoint(lat, lon, address = null) {
                StateManager.isManualCapture = true;
                StateManager.lastKnownPosition = { latitude: lat, longitude: lon };
                StateManager.lastKnownAccuracy = 0;
                
                if(address === null) {
                     UIManager.showMessage('Buscando endereço do ponto...', 'info');
                     StateManager.lastKnownAddress = await this.reverseGeocode(lat, lon);
                } else {
                     StateManager.lastKnownAddress = address;
                }

                StateManager.map.setView([lat, lon], 16);
                if (StateManager.manualMarker) StateManager.map.removeLayer(StateManager.manualMarker);
                StateManager.manualMarker = L.marker([lat, lon]).addTo(StateManager.map)
                    .bindPopup(`<b>${StateManager.lastKnownAddress}</b>`).openPopup();

                UIManager.updateCoordinatesDisplay(lat, lon, 0);
                UIManager.setUIState(true);
            },
        };

        // =================================================================
        // MÓDULO 4: DataManager - Gerencia os dados (CRUD, export)
        // =================================================================
        const DataManager = {
            LOCAL_STORAGE_KEY: 'to_the_point_coords',

            loadFromLocalStorage() {
                try {
                    const savedData = localStorage.getItem(this.LOCAL_STORAGE_KEY);
                    if (savedData) {
                        StateManager.localCoordinates = JSON.parse(savedData);
                        if (StateManager.localCoordinates.length > 0) {
                             UIManager.showMessage(`${StateManager.localCoordinates.length} pontos carregados.`, 'info');
                        }
                    }
                } catch (e) {
                    console.error("Erro ao carregar dados:", e);
                    localStorage.removeItem(this.LOCAL_STORAGE_KEY);
                }
            },
            
            saveToLocalStorage() {
                try {
                    localStorage.setItem(this.LOCAL_STORAGE_KEY, JSON.stringify(StateManager.localCoordinates));
                } catch (e) {
                    console.error("Erro ao salvar dados:", e);
                    UIManager.showMessage("Falha ao salvar backup local.", 'error');
                }
            },
            
            async addPoint() {
                if (!StateManager.lastKnownPosition) {
                    UIManager.showMessage("Nenhuma coordenada para capturar.", 'error');
                    return;
                }

                let addressToSave = StateManager.lastKnownAddress;
                if (!StateManager.isManualCapture) {
                    const shouldInclude = await UIManager.showConfirmation("Incluir endereço aproximado?");
                    if (shouldInclude) {
                        UIManager.showMessage('Buscando endereço...');
                        addressToSave = await MapManager.reverseGeocode(StateManager.lastKnownPosition.latitude, StateManager.lastKnownPosition.longitude);
                    } else {
                        addressToSave = 'Endereço não incluído';
                    }
                }

                const pointName = UIManager.elements.pointNameInput.value.trim() || `Ponto ${StateManager.localCoordinates.length + 1}`;
                const newPoint = {
                    id: Date.now(),
                    name: pointName,
                    latitude: StateManager.lastKnownPosition.latitude,
                    longitude: StateManager.lastKnownPosition.longitude,
                    accuracy: StateManager.lastKnownAccuracy,
                    address: addressToSave,
                    timestamp: new Date().toLocaleString('pt-BR', { timeZone: 'America/Sao_Paulo' }),
                    originalAccuracy: StateManager.isManualCapture ? 0 : StateManager.lastKnownAccuracy,
                    originalLat: StateManager.lastKnownPosition.latitude,
                    originalLon: StateManager.lastKnownPosition.longitude,
                };

                StateManager.localCoordinates.push(newPoint);
                this.saveToLocalStorage();
                UIManager.updatePreviewTable();
                UIManager.showMessage(`Ponto "${pointName}" capturado!`, 'success');
                
                // Lógica de sugestão para o próximo ponto
                const lastPointName = newPoint.name;
                // Regex: captura (qualquer coisa terminando em não-dígito e talvez espaço) e (dígitos no final)
                const match = lastPointName.match(/^(.*\D\s*)(\d+)$/);
                if (match) {
                    const prefix = match[1]; // Parte do texto
                    const number = parseInt(match[2]) + 1; // Incrementa o número
                    UIManager.elements.pointNameInput.value = `${prefix}${number}`;
                } else {
                    // Se o nome anterior não terminar em número, limpa o campo.
                    UIManager.elements.pointNameInput.value = '';
                }

                // Reseta estado para nova captura
                StateManager.lastKnownPosition = null;
                StateManager.lastKnownAccuracy = null;
                StateManager.lastKnownAddress = null;
                if (StateManager.manualMarker) StateManager.map.removeLayer(StateManager.manualMarker);
                StateManager.manualMarker = null;
                UIManager.setUIState(StateManager.isCollecting);
            },

            deletePoint(id) {
                StateManager.localCoordinates = StateManager.localCoordinates.filter(p => p.id !== id);
                this.saveToLocalStorage();
                UIManager.updatePreviewTable();
                UIManager.showMessage('Ponto deletado.', 'success');
            },

            updatePointName(id, newName) {
                const point = StateManager.localCoordinates.find(p => p.id === id);
                if (point) {
                    point.name = newName;
                    point.nameEdited = true; // Flag para indicar edição manual do nome
                    this.saveToLocalStorage();
                    UIManager.showMessage(`Nome do ponto atualizado para '${newName}'.`, 'success');
                    UIManager.updatePreviewTable(); // Atualiza o popup do marcador
                }
            },
            
            updatePointPosition(id, lat, lon) {
                const point = StateManager.localCoordinates.find(p => p.id === id);
                if (point) {
                    point.latitude = lat;
                    point.longitude = lon;
                    point.accuracy = 0; // Marcar como corrigido
                    point.address = 'Posição corrigida manualmente';
                    this.saveToLocalStorage();
                }
            },
            
            async clearAllData() {
                if (StateManager.localCoordinates.length === 0) return;
                const confirmed = await UIManager.showClearDataConfirmation();
                if (confirmed) {
                    MapManager.stopCollecting();
                    localStorage.removeItem(this.LOCAL_STORAGE_KEY);
                    StateManager.localCoordinates = [];
                    UIManager.updatePreviewTable();
                    UIManager.showMessage("Todos os dados locais foram limpos.", 'success');
                }
            },

            exportToCSV() {
                if (StateManager.localCoordinates.length === 0) {
                    UIManager.showMessage("Nenhum ponto para baixar.", 'error');
                    return;
                }
                let csvContent = "Nome;Lat_Final;Lon_Final;Status;Endereco;Timestamp;Lat_Original;Lon_Original;Precisao_Orig_m\n";
                StateManager.localCoordinates.forEach(p => {
                    const row = [
                        p.name,
                        p.latitude.toFixed(6).replace('.', ','),
                        p.longitude.toFixed(6).replace('.', ','),
                        this.getPointStatus(p),
                        `"${p.address || ''}"`,
                        p.timestamp,
                        p.originalLat.toFixed(6).replace('.', ','),
                        p.originalLon.toFixed(6).replace('.', ','),
                        this.getOriginalAccuracyText(p, true)
                    ].join(';');
                    csvContent += row + '\n';
                });

                const blob = new Blob([`\uFEFF${csvContent}`], { type: 'text/csv;charset=utf-8;' });
                const link = document.createElement("a");
                link.href = URL.createObjectURL(blob);
                link.download = "COORD.csv";
                link.click();
                URL.revokeObjectURL(link.href);
                UIManager.showMessage("Download do CSV iniciado.", 'success');
            },

            getPointStatus(point) {
                if (point.accuracy === 0 && point.originalAccuracy !== 0) return 'Corrigido Manualmente';
                if (point.originalAccuracy === 0) return 'Manual (Endereço)';
                if (point.originalAccuracy <= 5) return 'GPS (Alta Precisão)';
                if (point.originalAccuracy <= 15) return 'GPS (Média Precisão)';
                return 'GPS (Baixa Precisão)';
            },

            getOriginalAccuracyText(point, forCsv = false) {
                if (point.originalAccuracy === 0) return 'Manual';
                if (point.originalAccuracy) return forCsv ? point.originalAccuracy.toFixed(1).replace('.', ',') : `\u00B1 ${point.originalAccuracy.toFixed(1)}m`;
                return 'N/A';
            }
        };
        
        // =================================================================
        // MÓDULO 5: SettingsManager - Gerencia as configurações
        // =================================================================
        const SettingsManager = {
            API_KEY_STORAGE_KEY: 'to_the_point_api_key',
            THEME_STORAGE_KEY: 'to_the_point_theme',

            init() {
                UIManager.elements.apiKeyInput.value = this.getApiKey() || '';
            },

            saveApiKey(key) {
                localStorage.setItem(this.API_KEY_STORAGE_KEY, key);
            },

            getApiKey() {
                return localStorage.getItem(this.API_KEY_STORAGE_KEY);
            },
            
            saveTheme(theme) {
                localStorage.setItem(this.THEME_STORAGE_KEY, theme);
            },
            
            getTheme() {
                const savedTheme = localStorage.getItem(this.THEME_STORAGE_KEY);
                if (savedTheme) return savedTheme;
                return window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
            }
        };

        // =================================================================
        // MÓDULO 6: App - O orquestrador principal
        // =================================================================
        const App = {
            init() {
                // Inicializa todos os módulos
                SettingsManager.init();
                UIManager.init();
                MapManager.init();
                DataManager.loadFromLocalStorage();
                
                // Carrega os dados e atualiza a UI inicial
                UIManager.updatePreviewTable();

                // Adiciona os Event Listeners
                this.addEventListeners();
            },

            addEventListeners() {
                const el = UIManager.elements;
                el.startButton.addEventListener('click', () => MapManager.startCollecting());
                el.stopButton.addEventListener('click', () => MapManager.stopCollecting());
                el.captureButton.addEventListener('click', () => DataManager.addPoint());
                el.downloadButton.addEventListener('click', () => DataManager.exportToCSV());
                el.clearLocalDataButton.addEventListener('click', () => DataManager.clearAllData());
                el.themeToggle.addEventListener('click', () => UIManager.toggleDarkMode());
                el.searchButton.addEventListener('click', () => this.handleSearch());
                el.searchInput.addEventListener('keypress', (e) => e.key === 'Enter' && this.handleSearch());
                 el.manualCaptureButton.addEventListener('click', () => {
                    MapManager.stopCollecting();
                    StateManager.isManualCapture = true;
                    UIManager.showMessage('Clique no mapa para selecionar um ponto.', 'info');
                    UIManager.setUIState(true);
                });
                
                // Listeners dos Modais
                el.settingsButton.addEventListener('click', () => UIManager.showModal(el.settingsModal));
                el.closeSettingsButton.addEventListener('click', () => UIManager.hideModal(el.settingsModal));
                el.saveSettingsButton.addEventListener('click', () => this.handleSaveSettings());
            },

            handleSaveSettings() {
                const newKey = UIManager.elements.apiKeyInput.value.trim();
                SettingsManager.saveApiKey(newKey);
                UIManager.hideModal(UIManager.elements.settingsModal);
                UIManager.showMessage('Configurações salvas com sucesso!', 'success');
            },

            async handleSearch() {
                const query = UIManager.elements.searchInput.value.trim();
                 if (!query) {
                    UIManager.showMessage('Por favor, digite um endereço ou coordenadas para pesquisar.', 'error');
                    return;
                }
                const apiKey = SettingsManager.getApiKey();
                if (!apiKey) {
                    UIManager.showMessage('Configure sua chave de API do Google Maps nas configurações.', 'error');
                    return;
                }
                MapManager.stopCollecting();
                await MapManager.searchLocation(query);
            },
            
            handleDeletePoint(id) {
                DataManager.deletePoint(id);
            },

            handleEditPointName(element, id) {
                const newName = element.textContent.trim();
                if (newName) {
                    DataManager.updatePointName(id, newName);
                    element.classList.add('edited-flash');
                    setTimeout(() => element.classList.remove('edited-flash'), 1000);
                } else {
                    UIManager.showMessage('O nome do ponto não pode ser vazio.', 'error');
                    // Recarrega a tabela para reverter
                    UIManager.updatePreviewTable();
                }
            }
        };

        // Inicia a aplicação e torna funções globais acessíveis
        App.init();
        window.App = App; // Para os eventos onblur e onclick no HTML
    });
    </script>
</body>
</html>


